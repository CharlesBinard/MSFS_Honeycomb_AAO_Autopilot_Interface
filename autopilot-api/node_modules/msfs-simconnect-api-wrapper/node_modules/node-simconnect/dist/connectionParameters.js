"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.autodetectServerAddress = void 0;
const Path = require("path");
const os = require("os");
const debug_1 = require("debug");
const ini_1 = require("./utils/ini");
const registry_1 = require("./utils/registry");
const network_1 = require("./utils/network");
const logger = (0, debug_1.default)('node-simconnect');
function findSimConnectPortIPv4() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const port = yield (0, registry_1.readRegistryValue)('HKCU\\Software\\Microsoft\\Microsoft Games\\Flight Simulator', 'SimConnect_Port_IPv4');
            if (!port) {
                throw new Error('Could not find SimConnect_Port_IPv4 in the Windows registry');
            }
            return parseInt(port, 10);
        }
        catch (_a) {
            return 2048;
        }
    });
}
function readNetworkConfigFromSimConnectCfg(folderPath, index) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = Path.join(folderPath, 'SimConnect.cfg');
        let fullCfg;
        try {
            // SimConnect.cfg uses the INI fileformat
            fullCfg = yield (0, ini_1.readIniFile)(filePath);
        }
        catch (e) {
            logger('Could not read SimConnect.cfg due to to the following error:', e);
            return undefined;
        }
        if (fullCfg.SimConnect === undefined) {
            throw new Error(`Invalid SimConnect.cfg file: ${filePath}`);
        }
        const indexStr = index !== undefined ? index.toString(10) : '0';
        const cfg = fullCfg.SimConnect[indexStr] ? fullCfg.SimConnect[indexStr] : fullCfg.SimConnect;
        if (cfg.Protocol === undefined || cfg.Address === undefined || cfg.Port === undefined) {
            throw new Error(`The loaded SimConnect.cfg (${filePath}) is missing required parameters.`);
        }
        else if (cfg.Protocol && cfg.Protocol.toUpperCase() !== 'IPV4') {
            throw new Error('Only the Ipv4 protocol is supported at the moment');
        }
        return {
            type: 'ipv4',
            host: cfg.Address,
            port: parseInt(cfg.Port, 10),
        };
    });
}
function autodetectServerAddress(cfgIndex) {
    return __awaiter(this, void 0, void 0, function* () {
        // Check for SimConnect.cfg in current dir
        const localConfig = yield readNetworkConfigFromSimConnectCfg(process.cwd(), cfgIndex);
        if (localConfig)
            return localConfig;
        const homeConfig = yield readNetworkConfigFromSimConnectCfg(os.homedir(), cfgIndex);
        if (homeConfig)
            return homeConfig;
        if (cfgIndex !== undefined) {
            throw new Error(`No SimConnect.cfg file containing the given config index ${cfgIndex} was found`);
        }
        // Check if named pipe exist
        const PIPE = '\\\\.\\pipe\\Microsoft Flight Simulator\\SimConnect';
        const msfsSimconnectPipeOk = yield (0, network_1.checkIfNamedPipeExist)(PIPE);
        if (msfsSimconnectPipeOk) {
            return { type: 'pipe', address: PIPE };
        }
        // Read port number from Windows registry
        const ipv4port = yield findSimConnectPortIPv4();
        return { type: 'ipv4', host: 'localhost', port: ipv4port };
    });
}
exports.autodetectServerAddress = autodetectServerAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdGlvblBhcmFtZXRlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY29ubmVjdGlvblBhcmFtZXRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixpQ0FBMEI7QUFDMUIscUNBQTBDO0FBQzFDLCtDQUFxRDtBQUNyRCw2Q0FBd0Q7QUFFeEQsTUFBTSxNQUFNLEdBQUcsSUFBQSxlQUFLLEVBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUV4QyxTQUFlLHNCQUFzQjs7UUFDakMsSUFBSTtZQUNBLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBQSw0QkFBaUIsRUFDaEMsOERBQThELEVBQzlELHNCQUFzQixDQUN6QixDQUFDO1lBQ0YsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDUCxNQUFNLElBQUksS0FBSyxDQUFDLDZEQUE2RCxDQUFDLENBQUM7YUFDbEY7WUFDRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDN0I7UUFBQyxXQUFNO1lBQ0osT0FBTyxJQUFJLENBQUM7U0FDZjtJQUNMLENBQUM7Q0FBQTtBQU1ELFNBQWUsa0NBQWtDLENBQzdDLFVBQWtCLEVBQ2xCLEtBQWM7O1FBRWQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUV6RCxJQUFJLE9BQU8sQ0FBQztRQUNaLElBQUk7WUFDQSx5Q0FBeUM7WUFDekMsT0FBTyxHQUFHLE1BQU0sSUFBQSxpQkFBVyxFQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3pDO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixNQUFNLENBQUMsOERBQThELEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDMUUsT0FBTyxTQUFTLENBQUM7U0FDcEI7UUFFRCxJQUFJLE9BQU8sQ0FBQyxVQUFVLEtBQUssU0FBUyxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDL0Q7UUFFRCxNQUFNLFFBQVEsR0FBRyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDaEUsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztRQUU3RixJQUFJLEdBQUcsQ0FBQyxRQUFRLEtBQUssU0FBUyxJQUFJLEdBQUcsQ0FBQyxPQUFPLEtBQUssU0FBUyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQ25GLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLFFBQVEsbUNBQW1DLENBQUMsQ0FBQztTQUM5RjthQUFNLElBQUksR0FBRyxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxLQUFLLE1BQU0sRUFBRTtZQUM5RCxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDeEU7UUFFRCxPQUFPO1lBQ0gsSUFBSSxFQUFFLE1BQU07WUFDWixJQUFJLEVBQUUsR0FBRyxDQUFDLE9BQU87WUFDakIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztTQUMvQixDQUFDO0lBQ04sQ0FBQztDQUFBO0FBRUQsU0FBZSx1QkFBdUIsQ0FBQyxRQUFpQjs7UUFDcEQsMENBQTBDO1FBQzFDLE1BQU0sV0FBVyxHQUFHLE1BQU0sa0NBQWtDLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3RGLElBQUksV0FBVztZQUFFLE9BQU8sV0FBVyxDQUFDO1FBRXBDLE1BQU0sVUFBVSxHQUFHLE1BQU0sa0NBQWtDLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3BGLElBQUksVUFBVTtZQUFFLE9BQU8sVUFBVSxDQUFDO1FBRWxDLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUNYLDREQUE0RCxRQUFRLFlBQVksQ0FDbkYsQ0FBQztTQUNMO1FBRUQsNEJBQTRCO1FBQzVCLE1BQU0sSUFBSSxHQUFHLHFEQUFxRCxDQUFDO1FBQ25FLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxJQUFBLCtCQUFxQixFQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9ELElBQUksb0JBQW9CLEVBQUU7WUFDdEIsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQzFDO1FBRUQseUNBQXlDO1FBQ3pDLE1BQU0sUUFBUSxHQUFHLE1BQU0sc0JBQXNCLEVBQUUsQ0FBQztRQUNoRCxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztJQUMvRCxDQUFDO0NBQUE7QUFFUSwwREFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBQYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XHJcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XHJcbmltcG9ydCB7IHJlYWRJbmlGaWxlIH0gZnJvbSAnLi91dGlscy9pbmknO1xyXG5pbXBvcnQgeyByZWFkUmVnaXN0cnlWYWx1ZSB9IGZyb20gJy4vdXRpbHMvcmVnaXN0cnknO1xyXG5pbXBvcnQgeyBjaGVja0lmTmFtZWRQaXBlRXhpc3QgfSBmcm9tICcuL3V0aWxzL25ldHdvcmsnO1xyXG5cclxuY29uc3QgbG9nZ2VyID0gZGVidWcoJ25vZGUtc2ltY29ubmVjdCcpO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gZmluZFNpbUNvbm5lY3RQb3J0SVB2NCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwb3J0ID0gYXdhaXQgcmVhZFJlZ2lzdHJ5VmFsdWUoXHJcbiAgICAgICAgICAgICdIS0NVXFxcXFNvZnR3YXJlXFxcXE1pY3Jvc29mdFxcXFxNaWNyb3NvZnQgR2FtZXNcXFxcRmxpZ2h0IFNpbXVsYXRvcicsXHJcbiAgICAgICAgICAgICdTaW1Db25uZWN0X1BvcnRfSVB2NCdcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICghcG9ydCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIFNpbUNvbm5lY3RfUG9ydF9JUHY0IGluIHRoZSBXaW5kb3dzIHJlZ2lzdHJ5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZUludChwb3J0LCAxMCk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgICByZXR1cm4gMjA0ODtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgQ29ubmVjdGlvblBhcmFtZXRlcnMgPVxyXG4gICAgfCB7IHR5cGU6ICdwaXBlJzsgYWRkcmVzczogc3RyaW5nIH1cclxuICAgIHwgeyB0eXBlOiAnaXB2NCc7IGhvc3Q6IHN0cmluZzsgcG9ydDogbnVtYmVyIH07XHJcblxyXG5hc3luYyBmdW5jdGlvbiByZWFkTmV0d29ya0NvbmZpZ0Zyb21TaW1Db25uZWN0Q2ZnKFxyXG4gICAgZm9sZGVyUGF0aDogc3RyaW5nLFxyXG4gICAgaW5kZXg/OiBudW1iZXJcclxuKTogUHJvbWlzZTxDb25uZWN0aW9uUGFyYW1ldGVycyB8IHVuZGVmaW5lZD4ge1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSBQYXRoLmpvaW4oZm9sZGVyUGF0aCwgJ1NpbUNvbm5lY3QuY2ZnJyk7XHJcblxyXG4gICAgbGV0IGZ1bGxDZmc7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIFNpbUNvbm5lY3QuY2ZnIHVzZXMgdGhlIElOSSBmaWxlZm9ybWF0XHJcbiAgICAgICAgZnVsbENmZyA9IGF3YWl0IHJlYWRJbmlGaWxlKGZpbGVQYXRoKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIoJ0NvdWxkIG5vdCByZWFkIFNpbUNvbm5lY3QuY2ZnIGR1ZSB0byB0byB0aGUgZm9sbG93aW5nIGVycm9yOicsIGUpO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZ1bGxDZmcuU2ltQ29ubmVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFNpbUNvbm5lY3QuY2ZnIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW5kZXhTdHIgPSBpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXgudG9TdHJpbmcoMTApIDogJzAnO1xyXG4gICAgY29uc3QgY2ZnID0gZnVsbENmZy5TaW1Db25uZWN0W2luZGV4U3RyXSA/IGZ1bGxDZmcuU2ltQ29ubmVjdFtpbmRleFN0cl0gOiBmdWxsQ2ZnLlNpbUNvbm5lY3Q7XHJcblxyXG4gICAgaWYgKGNmZy5Qcm90b2NvbCA9PT0gdW5kZWZpbmVkIHx8IGNmZy5BZGRyZXNzID09PSB1bmRlZmluZWQgfHwgY2ZnLlBvcnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGxvYWRlZCBTaW1Db25uZWN0LmNmZyAoJHtmaWxlUGF0aH0pIGlzIG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVycy5gKTtcclxuICAgIH0gZWxzZSBpZiAoY2ZnLlByb3RvY29sICYmIGNmZy5Qcm90b2NvbC50b1VwcGVyQ2FzZSgpICE9PSAnSVBWNCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgdGhlIElwdjQgcHJvdG9jb2wgaXMgc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdpcHY0JyxcclxuICAgICAgICBob3N0OiBjZmcuQWRkcmVzcyxcclxuICAgICAgICBwb3J0OiBwYXJzZUludChjZmcuUG9ydCwgMTApLFxyXG4gICAgfTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gYXV0b2RldGVjdFNlcnZlckFkZHJlc3MoY2ZnSW5kZXg/OiBudW1iZXIpOiBQcm9taXNlPENvbm5lY3Rpb25QYXJhbWV0ZXJzPiB7XHJcbiAgICAvLyBDaGVjayBmb3IgU2ltQ29ubmVjdC5jZmcgaW4gY3VycmVudCBkaXJcclxuICAgIGNvbnN0IGxvY2FsQ29uZmlnID0gYXdhaXQgcmVhZE5ldHdvcmtDb25maWdGcm9tU2ltQ29ubmVjdENmZyhwcm9jZXNzLmN3ZCgpLCBjZmdJbmRleCk7XHJcbiAgICBpZiAobG9jYWxDb25maWcpIHJldHVybiBsb2NhbENvbmZpZztcclxuXHJcbiAgICBjb25zdCBob21lQ29uZmlnID0gYXdhaXQgcmVhZE5ldHdvcmtDb25maWdGcm9tU2ltQ29ubmVjdENmZyhvcy5ob21lZGlyKCksIGNmZ0luZGV4KTtcclxuICAgIGlmIChob21lQ29uZmlnKSByZXR1cm4gaG9tZUNvbmZpZztcclxuXHJcbiAgICBpZiAoY2ZnSW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgYE5vIFNpbUNvbm5lY3QuY2ZnIGZpbGUgY29udGFpbmluZyB0aGUgZ2l2ZW4gY29uZmlnIGluZGV4ICR7Y2ZnSW5kZXh9IHdhcyBmb3VuZGBcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIG5hbWVkIHBpcGUgZXhpc3RcclxuICAgIGNvbnN0IFBJUEUgPSAnXFxcXFxcXFwuXFxcXHBpcGVcXFxcTWljcm9zb2Z0IEZsaWdodCBTaW11bGF0b3JcXFxcU2ltQ29ubmVjdCc7XHJcbiAgICBjb25zdCBtc2ZzU2ltY29ubmVjdFBpcGVPayA9IGF3YWl0IGNoZWNrSWZOYW1lZFBpcGVFeGlzdChQSVBFKTtcclxuICAgIGlmIChtc2ZzU2ltY29ubmVjdFBpcGVPaykge1xyXG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdwaXBlJywgYWRkcmVzczogUElQRSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlYWQgcG9ydCBudW1iZXIgZnJvbSBXaW5kb3dzIHJlZ2lzdHJ5XHJcbiAgICBjb25zdCBpcHY0cG9ydCA9IGF3YWl0IGZpbmRTaW1Db25uZWN0UG9ydElQdjQoKTtcclxuICAgIHJldHVybiB7IHR5cGU6ICdpcHY0JywgaG9zdDogJ2xvY2FsaG9zdCcsIHBvcnQ6IGlwdjRwb3J0IH07XHJcbn1cclxuXHJcbmV4cG9ydCB7IGF1dG9kZXRlY3RTZXJ2ZXJBZGRyZXNzIH07XHJcbiJdfQ==